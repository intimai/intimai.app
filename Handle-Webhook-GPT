import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type, x-lgpd-public",
  "Access-Control-Allow-Methods": "POST, OPTIONS",
  "Access-Control-Allow-Credentials": "true"
};
// =============================
// üîê Fun√ß√µes de criptografia AES-256
// =============================
function encrypt(text) {
  const key = Deno.env.get("ENCRYPTION_KEY");
  if (!key) {
    console.error("‚ùå ENCRYPTION_KEY n√£o configurada");
    return text;
  }
  try {
    const encoder = new TextEncoder();
    const data = encoder.encode(text);
    const keyData = encoder.encode(key.slice(0, 32));
    const iv = crypto.getRandomValues(new Uint8Array(12));
    return crypto.subtle.importKey("raw", keyData, {
      name: "AES-GCM"
    }, false, [
      "encrypt"
    ]).then((cryptoKey)=>crypto.subtle.encrypt({
        name: "AES-GCM",
        iv
      }, cryptoKey, data)).then((encrypted)=>{
      const combined = new Uint8Array(iv.length + encrypted.byteLength);
      combined.set(iv);
      combined.set(new Uint8Array(encrypted), iv.length);
      return btoa(String.fromCharCode(...combined));
    }).catch((err)=>{
      console.error("‚ùå Erro ao criptografar:", err);
      return text;
    });
  } catch (err) {
    console.error("‚ùå Erro inesperado na criptografia:", err);
    return text;
  }
}
function decrypt(encryptedText) {
  const key = Deno.env.get("ENCRYPTION_KEY");
  if (!key) {
    console.error("‚ùå ENCRYPTION_KEY n√£o configurada");
    return encryptedText;
  }
  try {
    const encoder = new TextEncoder();
    const decoder = new TextDecoder();
    const keyData = encoder.encode(key.slice(0, 32));
    const combined = new Uint8Array(atob(encryptedText).split("").map((c)=>c.charCodeAt(0)));
    const iv = combined.slice(0, 12);
    const encrypted = combined.slice(12);
    return crypto.subtle.importKey("raw", keyData, {
      name: "AES-GCM"
    }, false, [
      "decrypt"
    ]).then((cryptoKey)=>crypto.subtle.decrypt({
        name: "AES-GCM",
        iv
      }, cryptoKey, encrypted)).then((decrypted)=>decoder.decode(decrypted)).catch((err)=>{
      console.error("‚ùå Erro ao descriptografar:", err);
      return encryptedText;
    });
  } catch (err) {
    console.error("‚ùå Erro inesperado na descriptografia:", err);
    return encryptedText;
  }
}
// =============================
// üß© Fun√ß√µes auxiliares
// =============================
async function decryptSensitiveData(data) {
  if (!data || typeof data !== "object") return data;
  const decrypted = {
    ...data
  };
  const sensitiveFields = [
    "intimadoNome",
    "documento",
    "telefone"
  ];
  for (const field of sensitiveFields){
    if (decrypted[field] && typeof decrypted[field] === "string") {
      console.log(`üîç Tentando descriptografar campo: ${field}`);
      decrypted[field] = await decrypt(decrypted[field]);
      console.log(`‚úÖ ${field} descriptografado:`, decrypted[field]);
    }
  }
  return decrypted;
}
// =============================
// üöÄ Servidor principal
// =============================
serve(async (req)=>{
  if (req.method === "OPTIONS") {
    return new Response("ok", {
      headers: corsHeaders
    });
  }
  try {
    const authHeader = req.headers.get("authorization");
    if (!authHeader) {
      console.log("‚ùå Chamada sem autentica√ß√£o");
      return new Response(JSON.stringify({
        error: "Missing authorization header"
      }), {
        status: 401,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    }
    const body = await req.json();
    const { webhookType, payload } = body;
    console.log("üì¨ Webhook recebido:", webhookType);
    console.log("üß† Payload original:", JSON.stringify(payload, null, 2));
    let webhookUrl;
    switch(webhookType){
      case "CRIACAO":
        webhookUrl = Deno.env.get("WEBHOOK_CRIACAO_URL");
        break;
      case "REATIVACAO":
        webhookUrl = Deno.env.get("WEBHOOK_REATIVACAO_URL");
        break;
      case "CANCELAMENTO":
        webhookUrl = Deno.env.get("WEBHOOK_CANCELAMENTO_URL");
        break;
      case "SUPORTE":
        webhookUrl = Deno.env.get("WEBHOOK_SUPORTE_URL");
        break;
      case "LGPD":
        webhookUrl = Deno.env.get("WEBHOOK_LGPD_URL");
        break;
      default:
        return new Response(JSON.stringify({
          error: "Invalid webhook type"
        }), {
          status: 400,
          headers: {
            ...corsHeaders,
            "Content-Type": "application/json"
          }
        });
    }
    if (!webhookUrl) {
      console.error(`‚ùå URL do webhook n√£o configurada para o tipo: ${webhookType}`);
      return new Response(JSON.stringify({
        error: `Webhook URL for type ${webhookType} not configured`
      }), {
        status: 500,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    }
    let payloadForN8N = {
      ...payload
    };
    if (payloadForN8N.data) {
      console.log("üîê Dados sens√≠veis detectados, iniciando descriptografia...");
      payloadForN8N.data = await decryptSensitiveData(payloadForN8N.data);
      console.log("üîì Dados ap√≥s descriptografia:", JSON.stringify(payloadForN8N.data, null, 2));
    } else {
      console.log("‚ö†Ô∏è Nenhum campo 'data' encontrado no payload.");
    }
    console.log("üöÄ Enviando payload final para N8N:", JSON.stringify(payloadForN8N, null, 2));
    const webhookResponse = await fetch(webhookUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(payloadForN8N)
    });
    if (!webhookResponse.ok) {
      const errorBody = await webhookResponse.text();
      console.error("‚ùå Erro no webhook:", webhookResponse.status, errorBody);
      return new Response(JSON.stringify({
        error: `Failed to forward webhook for ${webhookType}`,
        details: errorBody
      }), {
        status: 502,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    }
    console.log("‚úÖ Webhook enviado com sucesso!");
    return new Response(JSON.stringify({
      success: true
    }), {
      status: 200,
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json"
      }
    });
  } catch (error) {
    console.error("üí• Erro na Edge Function:", error);
    return new Response(JSON.stringify({
      error: "Internal Server Error",
      details: error.message
    }), {
      status: 500,
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json"
      }
    });
  }
});
